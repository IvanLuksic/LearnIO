"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_classes_1 = require("../../compile/error_classes");
const code_1 = require("../code");
const codegen_1 = require("../../compile/codegen");
const names_1 = __importDefault(require("../../compile/names"));
const compile_1 = require("../../compile");
const util_1 = require("../../compile/util");
const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema, it } = cxt;
        const { allErrors, baseId, schemaEnv: env, opts, validateName, self } = it;
        const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
        if (schema === "#" || schema === "#/")
            return callRootRef();
        const schOrFunc = compile_1.resolveRef.call(self, env.root, baseId, schema);
        if (schOrFunc === undefined)
            throw new error_classes_1.MissingRefError(baseId, schema);
        if (schOrFunc instanceof compile_1.SchemaEnv)
            return callValidate(schOrFunc);
        return inlineRefSchema(schOrFunc);
        function callRootRef() {
            if (env === env.root)
                return callRef(validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: env.root });
            return callRef(codegen_1._ `${rootName}.validate`, env.root, env.root.$async);
        }
        function callValidate(sch) {
            let v;
            if (sch.validate) {
                v = gen.scopeValue("validate", { ref: sch.validate });
            }
            else {
                const code = codegen_1._ `{validate: ${sch.validateName}}`;
                const wrapper = gen.scopeValue("wrapper", { ref: sch, code });
                v = codegen_1._ `${wrapper}.validate`;
            }
            callRef(v, sch, sch.$async);
        }
        function callRef(v, sch, $async) {
            if ($async)
                callAsyncRef(v, sch);
            else
                callSyncRef(v, sch);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                strictSchema: true,
                dataTypes: [],
                schemaPath: codegen_1.nil,
                topSchemaRef: schName,
                errSchemaPath: schema,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
        function callAsyncRef(v, sch) {
            if (!env.$async)
                throw new Error("async schema referenced by sync schema");
            const valid = gen.let("valid");
            gen.try(() => {
                gen.code(codegen_1._ `await ${code_1.callValidateCode(cxt, v, passCxt)}`);
                addEvaluatedFrom(v, sch);
                if (!allErrors)
                    gen.assign(valid, true);
            }, (e) => {
                gen.if(codegen_1._ `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
                addErrorsFrom(e);
                if (!allErrors)
                    gen.assign(valid, false);
            });
            cxt.ok(valid);
        }
        function callSyncRef(v, sch) {
            cxt.result(code_1.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v, sch), () => addErrorsFrom(v));
        }
        function addErrorsFrom(source) {
            const errs = codegen_1._ `${source}.errors`;
            gen.assign(names_1.default.vErrors, codegen_1._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
            gen.assign(names_1.default.errors, codegen_1._ `${names_1.default.vErrors}.length`);
        }
        function addEvaluatedFrom(source, sch) {
            var _a;
            if (!it.opts.unevaluated)
                return;
            const schEvaluated = (_a = sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
            // TODO refactor
            if (it.props !== true) {
                if (schEvaluated && !schEvaluated.dynamicProps) {
                    if (schEvaluated.props !== undefined) {
                        it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                    }
                }
                else {
                    const props = gen.var("props", codegen_1._ `${source}.evaluated.props`);
                    it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
                }
            }
            if (it.items !== true) {
                if (schEvaluated && !schEvaluated.dynamicItems) {
                    if (schEvaluated.items !== undefined) {
                        it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                    }
                }
                else {
                    const items = gen.var("items", codegen_1._ `${source}.evaluated.items`);
                    it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
                }
            }
        }
    },
};
exports.default = def;
//# sourceMappingURL=ref.js.map